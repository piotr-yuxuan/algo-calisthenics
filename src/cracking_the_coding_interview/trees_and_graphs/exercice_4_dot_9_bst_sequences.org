#+TITLE:Exercice 4.9: BST sequences
#+PROPERTY: header-args :tangle exercice_4_dot_9_bst_sequences.clj

#+BEGIN_QUOTE
BST Sequences: A binary search tree was created by traversing through
an array from left to right and inserting each element. Given a binary
search tree with distinct elements, print all possible arrays that
could have led to this tree.
#+END_QUOTE

#+BEGIN_SRC clojure
(ns cracking-the-coding-interview.trees-and-graphs.exercice-4-dot-9-bst-sequences
  (:require [clojure.test :refer [deftest is]]
            [clojure.string :as str]))
#+END_SRC

This kind of problem statement sounds perfect for logic
programming. However I want to restrict myself to Clojure standard
library and not use library like ~core.logic~.

The root value of such a binary tree must be the first item of the
array. This property holds recursively.

#+BEGIN_SRC clojure :tangle no
(def tree
  {:root 4
   4 [2 6]
   2 [1 3]
   6 [5 7]})
#+END_SRC

The leftmost subtree could be generated by =[2 1 3]= or =[2 3 1]=. Its
sibling the rightmost tree could be =[6 5 7]= or =[6 7 5]=. Their
parent tree could come from =[4 2 6]= or =[4 6 2]=.

However I will resist first the temptation to go down the rabbit hole
and exhibit a general algorithm as the statement is explicit about the
size of the tree: 3 distinct elements.

As it's a binary search tree only the following shapes of tree are
possible, presented here with their possible arrays:

#+BEGIN_SRC clojure :tangle no
(def shape-1
  {:root 2
   2 [1 3]})

(def shape-1-arrays
  #{[2 1 3]
    [2 3 1]})

(def shape-2
  {:root 1
   1 [nil 2]
   2 [nil 3]})

(def shape-2-arrays
  #{[1 2 3]})

(def shape-3
  {:root 1
   1 [nil 3]
   3 [2 nil]})

(def shape-3-arrays
  #{[1 3 2]})

(def shape-4
  {:root 3
   3 [2 nil]
   2 [1 nil]})

(def shape-4-arrays
  #{[3 2 1]})

(def shape-5
  {:root 3
   3 [1 nil]
   1 [2 nil]})

(def shape-5-arrays
  #{[3 1 2]})
#+END_SRC

So here is how to qualify the shape of a three-item binary search tree:

#+BEGIN_SRC clojure
(defn shape [t]
  (let [[left right] (get t (:root t))
        [sub-left sub-right] (get t (or left right))]
    (->> (vector (:root t)
                 left
                 right
                 sub-left
                 sub-right)
         (map boolean)
         vec)))

(def arrays
  {[true true true false false] (fn [t] (let [[left right] (get t (:root t))]
                                          (hash-set [(:root t) right left]
                                                    [(:root t) left right])))
   [true false true false true] (fn [t] (let [[_ right] (get t (:root t))
                                              [_ sub-right] (get t right)]
                                          (hash-set [(:root t) right sub-right])))
   [true false true true false] (fn [t] (let [[_ right] (get t (:root t))
                                              [sub-left _] (get t right)]
                                          (hash-set [(:root t) right sub-left])))
   [true true false true false] (fn [t] (let [[left _] (get t (:root t))
                                              [sub-left _] (get t left)]
                                          (hash-set [(:root t) left sub-left])))
   [true true false false true] (fn [t] (let [[left _] (get t (:root t))
                                              [_ sub-right] (get t left)]
                                          (hash-set [(:root t) left sub-right])))})
#+END_SRC

Function ~shape~ doesn't need to distinguish between ~left~ or ~right~
for ~sub-[left,right]~ because of the property of its argument: a
binary search tree made of three distinct nodes.

Here is how to use it:

#+BEGIN_SRC clojure
(defn bst-sequences [t]
  ((arrays (shape t)) t))

(deftest bst-sequences-test
  (is (= (bst-sequences {:root 2, 2 [1 3]})
         #{[2 1 3], [2 3 1]}))
  (is (= (bst-sequences {:root 1, 1 [nil 2], 2 [nil 3]})
         #{[1 2 3]}))
  (is (= (bst-sequences {:root 1, 1 [nil 3], 3 [2 nil]})
         #{[1 3 2]}))
  (is (= (bst-sequences {:root 3, 3 [2 nil], 2 [1 nil]})
         #{[3 2 1]}))
  (is (= (bst-sequences {:root 3, 3 [1 nil], 1 [2 nil]})
         #{[3 1 2]})))
#+END_SRC

However the current answer is too easy albeit it respects the problem
statement. What about I answering the problem for any arbitrary binary
search tree? The previous property still holds but we can rephrase it as:

#+BEGIN_QUOTE
The root value of a binary search tree must appear before any of its
children. This property holds recursively.
#+END_QUOTE

T

The general idea of the algorithm implemented here is to group nodes
by levels and gives all the combinations possible within those.
