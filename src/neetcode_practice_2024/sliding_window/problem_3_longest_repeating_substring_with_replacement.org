#+TITLE:Longest Repeating Character Replacement
#+PROPERTY: header-args :tangle longest_repeating_substring_with_replacement.py
#+STARTUP: latexpreview
#+URL: https://chatgpt.com/c/6795657d-b6e0-800e-89d6-442f858df070

#+BEGIN_QUOTE
You are given a string =s= consisting of only uppercase english
characters and an integer =k=. You can choose up to =k= characters of
the string and replace them with any other uppercase English
character.

After performing at most =k= replacements, return the length of the
longest substring which contains only one distinct character.
#+END_QUOTE

* Initial considerations

As usual we'll start with the brute force approach. However, on this
specific problem it is likely thinking too much about this approach
would be detrimental to creativity, so let's start with some thinking
about how to solve it.

We can reformulate the problem saying the case-insensitive string
matches the regular expression =[a-z]+=. As the section suggests a
sliding window approach is possible, in a $\mathcal{O}(n)$ linear time
complexity.

The general behaviour of sliding windows is to stretch toward the
right as long as a condition is met until it is broken, and then to
contract on the left until it is repaired. Here the condition on the
substring =fragment= within the window is:

#+BEGIN_QUOTE
The substring =fragment= of length $length = right\_bound -
left\_bound + 1$ is =k= replacements away from being made of only
single character repeated $length$ times.
#+END_QUOTE

Let's take an example with a simple string:

#+BEGIN_SRC python
a = "abbbbbbbaaaaaaacd"
len(a) == 17
len(set(a)) == 4
import collections
collections.Counter(a) == Counter({'a': 8, 'b': 7, 'c': 1, 'd': 1})
#+END_SRC

We'd need to change 9 characters into =a=, that's less expensive than
any other choices.

* Chosen solution

As of now the best way I can think ofâ€¦

- Time complexity (average / best / worst): $\mathcal{O}(n)$
- Space complexity (average / best / worst): $\mathcal{O}(1)$

#+BEGIN_SRC python
#+END_SRC
